/* -*- c++ -*- */
/*
 * Copyright 2004 Free Software Foundation, Inc.
 * 
 * This file is part of GNU Radio
 * 
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 * 
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

//FIXME Unix include stuff. Cleanup necessary.
#include <stdio.h>   /* Standard input/output definitions */
#include <string.h>  /* String function definitions */
#include <unistd.h>  /* UNIX standard function definitions */
#include <fcntl.h>   /* File control definitions */
#include <errno.h>   /* Error number definitions */
#include <termios.h> /* POSIX terminal control definitions */

#include <openmind_source.h>
#include <gr_io_signature.h>

/*
 * Create a new instance of myBlock and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
openmind_source_sptr
make_openmind_source (const std::string& device)
{
  return openmind_source_sptr(new openmind_source(device));  
}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr_block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 1 input and 1 output.
 */
static const int MIN_OUT = 4;	// minimum number of output streams
static const int MAX_OUT = 4;	// maximum number of output streams

/*
 * The private constructor
 */
openmind_source::openmind_source (const std::string& device)
  : gr_sync_block ("openmind_source",
		   gr_make_io_signature (0, 0, 0),
		   gr_make_io_signature (MIN_OUT, MAX_OUT, sizeof(short))),
		   d_device(device)
{
  
}

/*
 * Our virtual destructor.
 */
openmind_source::~openmind_source ()
{
	//Nothing do here (yet) 
}

int 
openmind_source::work (int noutput_items,
			gr_vector_const_void_star &input_items,
			gr_vector_void_star &output_items)
{
	short* current_items[output_items.size()];
	for (unsigned int i=0; i<output_items.size(); i++)
	{
		current_items[i] = (short*) output_items[i];
	}
	char buf[64]; //should be enough for at least 8ch
	char* bufp = 0;
	int sample_count = 0;
	for(; sample_count < noutput_items; sample_count++){
		int error_code;
		char c;
		int state = 0;
		//Sorry for the crappy state machine. If this should not be clear enough, write me a mail and I'll fix it. ;)
		for(bufp = buf; (error_code = read(port_fd, &c, 1)) == 1 && bufp < buf + 31;){ //Have to account for trailing \0 here
			if(state == 1){
				if(c == ']'){
					state = 0;
					//Received a block
					break;
				}else if(c == '\\'){
					 state = 2;
				}
			}
			switch(state){
			case 0:
				 if(c == '[')
					state = 1;
				 break;
			case 2:
				*bufp = c;
				bufp ++;
				state = 3;
				break;
			case 3:
				state = 1;
				break;
			}
		}
		*bufp = '\0';
		if(error_code != 1){
			//FIXME what to do with errors in here??
		}else{
			//Ok, we did not catch an error but saw a complete block. Let's extract the data, and for good measure we do
			//this using cstrings. Nevertheless any person in possession of a good code taste is warmly invited to port
			//this to just another great API, for now I just want to get this working.
			char* saveptr;
			char* token;
			int i=0;
			while(token = strtok_r(buf, " ", &saveptr)){
				/// \todo automatic vref acquisition
				char* endptr;
				//FIXME The following line is pretty certainly crap inherited from previous versions of this code.
				*current_items[i] = (short int)(strtol(token, &endptr, 16));// /(ADS_VREF/((2^15)-1.0F)));
				if(*endptr != 0){
					//An error occured (most likely some glitch between this code and the openmind firmware).
					//FIXME implement some error handling *here*
				}
				current_items[i]++;
				i++;
				if(i > output_items.size()){
					//ERROR!!1!
					break;
				}
			}
		}

	}
	return sample_count;
}

bool openmind_source::start(){
	struct timeval universal_timeout = {0, 1000};
	port_fd = open(d_device.c_str(), O_RDWR | O_NOCTTY | O_NDELAY);
	fd_set port_fds;
	if(port_fd == -1){
		return false; //I'm guessing this is the "failure" return value.
	}
	fcntl(port_fd, F_SETFL, 0);
	struct termios options;
	tcgetattr(port_fd, &options);
	//Set baud rate to 115200 Bd (BusPirate standard)
	cfsetspeed(&options, B115200);
    options.c_cflag |= (CLOCAL | CREAD); //Enable reciever, do not take ownership of the port. NOTE: does the transmitter also need to be enabled?
    options.c_cflag &= ~CSIZE;
	options.c_cflag &= ~PARENB; //no parity
	options.c_cflag &= ~CSTOPB; //1 stopbit
	options.c_cflag &= ~CSIZE;
    options.c_cflag &= ~CRTSCTS; //no hardware flow control
	options.c_cflag |= CS8; //8-bit chars
	tcsetattr(port_fd, TCSANOW, &options);
	((gr_block*)this)->start();

	int tries = 0;
	char buf[6];
	char* bufp = buf;
	int nread = 0;
	//Sorry for the endless loop, but I think it is more clear like this.
	while(1){
		//In fact I do not know if every char of the init string counts as one "try". Anyway, I do not think that is too
		//important.
	    if(tries++ == 20){
			return false; //Again: this value is just guessed!
	    }else{
			char c=0;
    	    if(write(port_fd, &c, 1) < 0){
				return false; //Write error
			}else{
				FD_ZERO(&port_fds);
				FD_SET(port_fd, &port_fds);
				if(!select(1, &port_fds, NULL, NULL, &universal_timeout) < 0){ //Wait 1 millisecond for a reply
					//Port ready for reading
					int count = read(port_fd, bufp, 5-nread);
					if(count<0){
						return false; //Some read error.
					}else{
						bufp += count;
						nread += count;
						if(nread == 5){
							break; //Read complete.
						}
					}
				}
    	    }
    	}
	}
	buf[5] = 0;
	if(strncmp(buf, "BBIO1", sizeof(buf))){
		return false; //Error in the bp binary mode initialization response string
	}
	char c = 0x01;
	if(write(port_fd, &c, 1) < 0){
			return false; //write error
	}
	for(nread,bufp = 0,buf; nread<4;){
		FD_ZERO(&port_fds);
		FD_SET(port_fd, &port_fds);
		if(select(1, &port_fds, NULL, NULL, &universal_timeout)){
			return false; //Timeout
		}
		int ret = read(port_fd, bufp, 6-nread);
		if(ret < 0){
			return false; //read error
		}
		nread += ret;
		bufp += ret;
	} 
	if(strncmp(buf, "SPI1", sizeof(buf))){
		return false; //Normally, SPI mode would be entered now.
	}
	c = 0x80;
	if(write(port_fd, &c, 1) < 0){
		return false; //write error
	}
	FD_ZERO(&port_fds);
	FD_SET(port_fd, &port_fds);
	if(select(1, &port_fds, NULL, NULL, &universal_timeout)){
		return false; //Timeout
	}
	if(read(port_fd, &c, 1) != 1){
		return false; //read error
	}
	if(c != 0x01){
		return false; //Wrong response
	}
	c = 0x0E;
	if(write(port_fd, &c, 1) < 0){
		return false; //write error
	}
	FD_ZERO(&port_fds);
	FD_SET(port_fd, &port_fds);
	if(select(1, &port_fds, NULL, NULL, &universal_timeout)){
		return false; //Timeout
	}
	if(read(port_fd, &c, 1) != 1){
		return false; //read error
	}
	if(c != 0x01){
		return false; //Wrong response
	}
	//Jackpot!
	return true;
}
